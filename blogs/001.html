<link rel="stylesheet" href="https://unpkg.com/tachyons@4.12.0/css/tachyons.min.css"/>


<nav class="pa3 pa4-ns">
	<a class="link dim black b f6 f5-ns dib mr3" href="../index.html" title="MattSewall">Matt Sewall</a>
	<a class="link dim gray    f6 f5-ns dib mr3" href="../about.html" title="About">About</a>
	<a class="link dim gray    f6 f5-ns dib mr3" href="../blog.html" title="Blog">Blog</a>
	<a class="link dim gray    f6 f5-ns dib mr3" href="../bookshelf.html" title="Bookshelf">Bookshelf</a>
</nav>

<article>
  <header class="sans-serif">
    <div class="mw9 center pa4 pt5-ns ph7-l">
      <time class="f6 mb2 dib ttu tracked"><small>27 July, 2015</small></time>
      <h3 class="f2 f1-m f-headline-l measure-narrow lh-solid mv0">
        <span class="black pa1">
          Finding a Middle Ground: Python Testing Coverage
        </span>
      </h3>
      <h4 class="f3 fw1 georgia i">In a world where types can only be hinted and tests act as the compiler, is anything less
      than 100% coverage acceptable? If so, what is the minimum bar?</h4>
    </div>
  </header>
  <div class="pa4 ph7-l georgia mw9-l center">
      <p class="f5 f3-ns measure georgia">
      Introduction: "100% testing coverage in Python does not mean that testing is good,
      however without 100% testing coverage the testing cannot be good"

      Section: Considering codebase invariants that can / cannot be assumed
      - Arg: What do tests actually test in an interpreted language / Python?
         - Functionality
         - It syntactically works
         - The test works in the virtual environment provided
         - Consider an example of changing a function signature called in 3 places
         - Segue into branch vs line coverage
      - Arg: Branch and line Coverage


      Section: Approaching a codebase as a living document
      - Arg: Ignored sections of covered code
         - Argument might work if code is not a living document
         - Cannot assume that multiple diffs use the function in the exact same way for the
         exact same purpose
         - Give example of function being used differently for different diffs
      - Arg: Minimum bars
         - With no diff, minimum coverage will always trend towards minimum coverage requirement
         - Diffs until the overall bar is reached cannot be assumed to have any coverage at all
         - Diff requirements are good, but bring us back to original issue
         - Add a graph

      Section: Toil
      - Arg: Initial quote _has_ to be correct as theory
      - Arg: Are there scenarios where it's still not worth it?
         - "Well it's still working after all this time..."
         - "Well it doesn't matter and that's why we choose Python..."
      - Arg: Avoiding mindless tests whenever possible
         - Prefer migrations to writing tests for existing code
         - Living document theory
         - No need to maintain old code if deemed lack of confidence

      Section: Conclusion
      - Arg: Pay price of dynamically type language or just use types?
         - No Types: Price in either lack of confidence or horde of tests
         - Types: Always will take a migration (mypy vs actual language change)

      </p>
      <p class="f5 f3-ns measure georgia">
        Notes:
      </p>
      <ul>
         <li>
            <p class="f5 f3-ns measure georgia">
              The concept of testing pyramid was ignored for the entirety of this article as
              the arguments presented about coverage should apply to any level of the pyramid regardless
              of granularity.
            </p>
         </li>
         <li>
            <p class="f5 f3-ns measure georgia">
              In practice there is quite a bit more to shipping reliable Python than simply "writing good tests".
              Enforcing hermetic tests, providing sane developer virtual environments with unobtrusive debuggers, and
              a well thought out release process will all do more to empower developers to easily avoid incidents before
              they happen.
            </p>
         </li>
      </ul>
      <p class="f5 f3-ns lh-copy measure georgia">
        In 1958 he published a piece in Venture proclaiming what he called "Sturgeon's Revelation"
      </p>
    <p class="f6 f5-ns lh-copy measure i pl4 bl bw1 b--gold mb4">
      I repeat Sturgeon's Revelation, which was wrung out of me after twenty years of wearying defense of science fiction against attacks of people who used the worst examples of the field for ammunition, and whose conclusion was that ninety percent of SF is crud. Using the same standards that categorize 90% of science fiction as trash, crud, or crap, it can be argued that 90% of film, literature, consumer goods, etc. is crap. In other words, the claim (or fact) that 90% of science fiction is crap is ultimately uninformative, because science fiction conforms to the same trends of quality as all other artforms.
    </p>
    <p class="f5 f4-ns lh-copy measure mb4">
    You don't have to bounce a tennis ball very far in San Francisco before it will hit two developers complaining about how many js tools/frameworks there are for development in 2015 and how much unneccessary complexity they add. Doing a search on twitter for 'too many js tools' or 'yet another js framework' returns... a lot of people lamenting the current state of affairs.
  </p>

    <p class="f5 f4-ns lh-copy measure">
    This is most likely, the wrong conversation for us as a community, to be having. The presence of bad tools - shouldn't discourage us from wanting more tools or frameworks. There are more books published in a single day than I will ever be able to read in my lifetime. But this does not make me sad. Or overwhelm me. Mostly I think about how excited I am to read the best books that are being published. And this is where we should push the conversation. How do we build better tools? What does that look like?
  </p>
  </div>
</article>
